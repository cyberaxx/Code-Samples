import java.util.Comparator;
import java.io.File;

public class Merge {
  // merge sort with comparator object as input
  private static void sort (Object[] src, Object[] dst, int lo, int hi, Comparator comparator) {
    if (hi <= lo) return ;
    int mid = (hi+lo)/2;

    sort(dst, src, lo, mid, comparator);
    assert isSorted(dst, lo, mid, comparator);

    sort(dst, src, mid+1, hi, comparator);
    assert isSorted(dst, mid+1, hi, comparator);

    if( !(less(src[mid+1], src[mid], comparator)) ) {
      System.arraycopy(src, lo, dst, lo, hi-lo+1);
      return ;
    }
    merge(src, dst, lo, mid, hi, comparator);
    assert isSorted(src, lo, hi, comparator);
  }
 
  private static void merge (Object[] src, Object[] dst, int lo, int mid, int hi, Comparator comparator) {
    assert isSorted(src, lo, mid, comparator); // LEFT
    assert isSorted(src, mid+1, hi, comparator);  // RIGHT


    int i = lo;
    int j = mid+1;

    for(int k=lo; k<=hi; k++) { 
      if(i>mid) dst[k] = src[j++];
      else if (j>hi) dst[k] = src[i++];
      else if (less(src[j], src[i], comparator)) dst[k] = src[j++];
      else dst[k] = src[i++];
    }
    assert isSorted(dst, lo, hi, comparator);
  }

  public static void sort (Object [] src, Comparator comparator) {
    Object[] dst = src.clone();
    sort(dst, src, 0, src.length-1, comparator); 
    assert isSorted(src, comparator);
  }

  private static boolean isSorted(Object[] items, Comparator comparator) {
    return isSorted(items, 0, items.length-1, comparator);
  }

  private static boolean isSorted(Object[] src, int lo, int hi, Comparator comparator) {
    for(int i=lo+1; i<=hi; i++)
      if (less(src[i], src[i-1], comparator)) return false;
    return true;
  }

  private static boolean less (Object v, Object w, Comparator comparator) {
    return comparator.compare(v,w) < 0;
  }

  private static void exch (Object[] src, int i, int j) {
    Object temp = src[i];
    src[i] = src[j];
    src[j] = temp;
  }

  // Sort subroutine:
  // Recursive method, using an Array of Comparable objects as input, 
  // Since the output is an Array of Comparable objects, we MUST avoid,
  // Creating arrys within recursive calls, rather, pass the entire Array to 
  // each call, and work on different portion of it, using lo and hi indeces:
  private static void sort (Comparable [] src, Comparable [] dst, int lo, int hi) {
    // base case:
    // Dividing phase: array halving
    if(lo>=hi) return; // stop when the lo pointer passes the hi pointer
    int mid = (lo+hi)/2; // find the middle of the array
    
    // Recursive calls:
    // on the left subarray:  
    sort(dst, src, lo, mid);
    // on the right subarray:
    sort(dst, src, mid+1, hi);
    // dst array always maintain isSorted invariance
    // within its boundaries
    
    // Check if the lo-hi array is already sorted, 
    // no need to merge:
    // if the SMALLEST element in the SORTED RIGHT half (src[mid+1])
    // is NOT LESS (so it's is larger or EQUAL) than  the LARGEST element in SORTED LEFT half (src[mid])
    // then there is no need to merge, cause the array is already sorted from lo-hi:
    if (!less(src[mid+1], src[mid])) {
      // faster than for loop, cause its implementation
      // is closer to the java interpreter:
      System.arraycopy(src, lo, dst, lo, hi-lo+1); // copy from src array from lo index, to dst array from its lo index, hi-lo+1 elements
      return ;
    }

    // Combine the results of recursive calls:
    // this step is little mind bending:
    // we call merge on (src, dst, ....) unlike the sort(dst, src, ...)
    // then use src array as an dst array to populate the dst array in sorted oreder 
    // in O(n) time by scanning src array from lo to hi:
    mergeCombine(src, dst, lo, mid, hi);

    // Invariant: The dst array is ALWAYS sorted within left and right boundaries
  }

  // O(n) for combining the result of divisions using Divide and Conquer approach  
  private static void mergeCombine (Comparable [] src, Comparable [] dst, int lo, int mid, int hi) {
    // This method would merge two sorted subarryas:
    // First sorted subarray is from lo-mid
    assert isSorted(src, lo, mid);
    // Second sorted subarray is from mid+1-hi
    assert isSorted(src, mid+1, hi);

    // And merge them into a sorted subarray from lo-hi
    int i=lo; // pointer index on left subarray;
    int j=mid+1; // pointer index on the right subarray
    
    // merger from lo-hi (inclusive)
    for (int k=lo; k<=hi; k++) {
      // Trivial cases: if either of subarrays has been exhauseted:
      // read from the other one:
      // 1. if the left subarray has been exhausted:
      if(i>mid) dst[k] = src[j++]; // read from the right subarray and advance its pointer
      // 2. if the right subarray has been exhausted:
      else if(j>hi) dst[k] = src[i++]; // read from the left subarray and advance its pointer

      // if the item at the j-th position at the right subarray was 
      // less than an item on the i-th position of the left subarray
      // read from the right subarray and advance its pointer
      else if(less(src[j], src[i])) dst[k] = src[j++];
   
      // if none of the conditions above holds, then 
      // read from the left subarray and advance its pointer
      else dst[k] = src[i++];
    }
    assert isSorted(dst, lo, hi);
  }

  public static void sort (Comparable [] src) {
    // Comparable [] dst = new Comparable [src.length];
    // Create a aux array and put a copy of src array in it:
    Comparable [] dst = src.clone(); // clone() method, creates and returns a copy of src Comparable Array object.
    sort (dst, src, 0, src.length-1);
    assert isSorted(src);
  }

  private static boolean less (Comparable v, Comparable w) {
    return v.compareTo(w) < 0;
  }
  
  private static boolean isSorted (Comparable [] src, int lo, int hi) {
    for(int i=lo+1; i<=hi; i++) 
      if(less(src[i], src[i-1])) return false;
    return true;
  }

  private static boolean isSorted (Comparable [] items) {
    return isSorted(items, 0, items.length-1);
  }
  // Let's write a sort client for the Selection sort:
  public static void main (String [] args) {
    // Sort with Comparable example:
    File directory = new File (args[0]);
    File [] files = directory.listFiles();
    // sort the array of files
    Merge.sort(files);
    for(int i=0; i<files.length;i++) System.out.println(files[i].getName());

    System.out.println();

    // Sort with Comparator example:
    String [] str = {"Shervin", "sas", "Nice", "dUde", "Dude"};
    // sort the array of files
    Merge.sort(str, String.CASE_INSENSITIVE_ORDER);
    for(int i=0; i<str.length;i++) System.out.println(str[i]);

    System.out.println();

    // Sort with Comparable example:
    Merge.sort(str);
    for(int i=0; i<str.length;i++) System.out.println(str[i]);
  }

}
