/*
Given a non-negative number represented as a singly linked list of digits, plus one to the number.

The digits are stored such that the most significant digit is at the head of the list.

Example:

Input:
1->2->3

Output:
1->2->4

Have to do it in O(n) time and O(1) space.
*/
 
import java.util.Collection;
import java.util.Deque;
import java.util.ArrayDeque;
import java.util.Collections;
import java.util.Arrays;


public class ListNode<Item> {
  private Item data;
  private PluseOneLL next;
  
  public static <Item> PluseOneLL<Item> addOne(PluseOneLL<Item> head) {
    // Handle trivial cases: empty list:
    if(head==null) return head;

    // use a stack to reverse the order:
    Deque<PluseOneLL> stack = new ArrayDeque<Item>();
    PluseOneLL currentNode=head;

    // push the nodes from the list to the stack
    while(currentNode!=null) {
    }
    return head;
  }

}
